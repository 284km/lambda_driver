{"name":"LambdaDriver","tagline":"虚弦斥力場生成システム","body":"# LambdaDriver\r\n\r\n虚弦斥力場生成システム\r\n\r\nLambdaDriver drives your code more functional.\r\n\r\n```ruby\r\n# [:foo, :bar, :baz].map{|s| s.to_s }.map{|s| s.upcase }\r\n# [:foo, :bar, :baz].map(&:to_s).map(&:upcase)\r\n\r\n[:foo, :bar, :baz].map(&:to_s >> :upcase ) # => [\"FOO\",  \"BAR\",  \"BAZ\"]\r\n```\r\n\r\n```ruby\r\n# [:foo, :hoge, :bar, :fuga].select{|s| s.to_s.length > 3} # => [:hoge, :fuga]\r\n\r\n[:foo, :hoge, :bar, :fuga].select(&:to_s >> :length >> 3._(:<)) # => [:hoge, :fuga]\r\n```\r\n\r\n- [project page](http://yuroyoro.github.com/lambda_driver/)\r\n- [rubygems.org](https://rubygems.org/gems/lambda_driver)\r\n\r\n## Build status\r\n\r\n[![Build Status](https://travis-ci.org/yuroyoro/lambda_driver.png)](https://travis-ci.org/yuroyoro/lambda_driver)\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'lambda_driver'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install lambda_driver\r\n\r\n## Usage\r\n\r\n### Proc/lambda/Symbol/Method extensions\r\n- call\r\n- compose\r\n- with_args\r\n- flip\r\n- curry\r\n\r\n#### alias :< to Proc#call\r\n\r\n```ruby\r\n  f = lambda{|x| x.to_s }\r\n  f < :foo # => \"foo\"\r\n```\r\n\r\n#### alias :+@ to Proc#to_proc\r\n\r\n```ruby\r\n  +:to_s           # => #<Proc:0x007ff78aadaa78>\r\n  +:to_s < :foo    # => \"foo\"\r\n```\r\n\r\n\r\n#### Proc#compose\r\n\r\nReturns new lambda which composed self and given function.\r\nA composed proc called with args, executes `self.(g(*args)).\r\n\r\n```ruby\r\n  f = lambda{|x| x.to_s * 2 }\r\n  g = lambda{|y| y.length }\r\n\r\n  h = f.compose g  # => #<Proc:0x007ff78aa2ab2>\r\n  h.(:hoge)        # => \"44\" ( == f.call(g.call(:hoge)) )\r\n```\r\n\r\nThis method is aliased as `<<`.\r\n\r\n```ruby\r\n  f << g          # => f.compose(g)\r\n  f << g < :hoge  # => \"44\" ( == f.call(g.call(:hoge)) )\r\n```\r\n\r\n#### Proc#with_args\r\n\r\nReturns partially applied function that has 2nd and more parameters are\r\nfixed by given *args.\r\n\r\n```ruby\r\n  f = lambda{|x, y, z| [x, y, z]}\r\n\r\n  h = f.with_args(:a, :b)   # => #<Proc:0x007ff78a9c5ca0>\r\n  h.(:c)                    # => [:c, :a, :b] ( == f.call(:c, :a, :b) )\r\n```\r\n\r\nThis method is aliased as `*`.\r\n\r\n```ruby\r\n  f = lambda{|x, y| [x, y]}\r\n\r\n  f * :foo          # => #<Proc:0x007ff78a987540> (== f.with_args(:foo) )\r\n  f * :foo < :bar   # => [:bar,  :foo] ( == f.with_args(:foo).call(:bar) )\r\n```\r\n\r\n\r\n#### Proc#flip\r\n\r\nReturns function whose parameter order swaped 1st for 2nd.\r\nA result of filped fuction is curried by Proc#curry.\r\n\r\n```ruby\r\n  f = lambda{|x, y, z| [x, y, z]}\r\n\r\n  h = f.flip                    # => #<Proc:0x007ff78a942fa>\r\n  h.call(:a).call(:b).call(:c)  # => [:b, :a, :c] (== f.curry.call(:b).call(:a).call(:b))\r\n  h < :a < :b < :c              # => [:b, :a, :c] (== f.curry.call(:b).call(:a).call(:b))\r\n```\r\n\r\nIf arguments is var-args, pass explicitly arity to curring.\r\n\r\n```ruby\r\n  p = Proc.new{|*args| args.inspect }\r\n\r\n  p.arity                           # => -1\r\n  p.flip(3).call(:a).(:b).(:c)      # => \"[:b, :a, :c]\"\r\n  p.flip(4).call(:a).(:b).(:c).(:d) # => \"[:b, :a, :c, :d]\"\r\n```\r\n\r\nIf arity is 0 or 1, flip returns itself.\r\n\r\nThis method is aliased as `~@`.\r\n\r\n```ruby\r\n  ~f # =>             #<Proc:0x007ff78a8e22c> (== f.filp)\r\n  ~f < :a < :b < :c   # => [:b, :a, :c] (== f.filp.call(:b).call(:a).call(:b))\r\n\r\n```\r\n\r\n### Symbol extensions\r\n- to_method\r\n\r\n#### Symbol#to_method\r\n\r\nSymbol#to_method generates a function that extract Method object from given arguments.\r\nThis method is aliased as `-@`.\r\n\r\n```ruby\r\n  (-:index).call(\"foobarbaz\")             # => #<Method: String#index>\r\n  (-:index).call(\"foobarbaz\").call(\"bar\") # => 3 (== \"foobarbaz\".index(3) )\r\n\r\n  -:index < \"foobarbaz\"         # => #<Method: String#index>\r\n  -:index < \"foobarbaz\" < \"bar\" # => 3 (== \"foobarbaz\".index(3) )\r\n```\r\n\r\n### Class extensions\r\n- alias instance_method, :/\r\n\r\n```ruby\r\n  String / :index # => #<UnboundMethod: String#index>\r\n```\r\n\r\n### UnboundMethod extensions\r\n- alias bind, :<\r\n\r\n```ruby\r\n  String / :index                    # => #<UnboundMethod: String#index>\r\n  String / :index < \"foobarbaz\"      # => #<Method: String#index>\r\n  String / :index < \"foobarbaz\" < 3  # => 3 (== \"foobarbaz\".index(3) )\r\n```\r\n\r\n### Combinators\r\n<!-- - && || -->\r\n- ski combinator\r\n\r\n### Object extensions\r\n- obj.ap(|>)\r\n- obj._\r\n- obj.disjunction(f)\r\n\r\n#### Object#revapply\r\n\r\n`Object#revapply` is applies self to given proc/block.\r\n\r\n```ruby\r\n  f = lambda{|x| x * 2 }\r\n\r\n  \"foo\".revapply(f) #  => \"fooffoo\" (== f.call(\"foo\") )\r\n```\r\n\r\n#### Object#_\r\n\r\nObject#_ is shortcut to quickly extract Method object.\r\n\r\n```ruby\r\n\"foobarbaz\"._.index         # => #<Method: String#index>\r\n\"foobarbaz\"._.index < \"bar\" # => 3 (== \"foobarbaz\".index(3) )\r\n\r\n2._(:>=)                    # => #<Method: Fixnum#>=>\r\n[1, 2, 3].select(&2._(:>=)) # => [1, 2]( = [1, 2].select{|n| 2 >= n})\r\n```\r\n\r\n#### Object#disjunction\r\n\r\n`Object#disjunction` select self or result of applied self to given function.\r\nif f(self) is nil, returns self, otherwise return f(self).\r\n\r\n```ruby\r\n  f = lambda{|x| x % 2 == 0 ? nil : x * 2}\r\n\r\n  2.disjunction(f) # => 2 (disjunction returns reciever object)\r\n  3.disjunction(f) # => 6 (disjunction returns f(3) )\r\n```\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}