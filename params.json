{"name":"LambdaDriver","tagline":"虚弦斥力場生成システム","body":"# LambdaDriver\r\n\r\n虚弦斥力場生成システム\r\n\r\nLambdaDriver drives your code more functional.\r\n\r\n```ruby\r\n# [:foo, :bar, :baz].map{|s| s.to_s }.map{|s| s.upcase }\r\n# [:foo, :bar, :baz].map(&:to_s).map(&:upcase)\r\n\r\n[:foo, :bar, :baz].map(&:to_s >> :upcase ) # => [\"FOO\",  \"BAR\",  \"BAZ\"]\r\n```\r\n\r\n```ruby\r\n# [:foo, :hoge, :bar, :fuga].select{|s| s.to_s.length > 3} # => [:hoge, :fuga]\r\n\r\n[:foo, :hoge, :bar, :fuga].select(&:to_s >> :length >> 3._(:<)) # => [:hoge, :fuga]\r\n```\r\n\r\n- [project page](http://yuroyoro.github.com/lambda_driver/)\r\n- [rubygems.org](https://rubygems.org/gems/lambda_driver)\r\n\r\n## Build status\r\n\r\n[![Build Status](https://travis-ci.org/yuroyoro/lambda_driver.png)](https://travis-ci.org/yuroyoro/lambda_driver)\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'lambda_driver'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install lambda_driver\r\n\r\n## Usage\r\n\r\n### Proc/lambda/Symbol/Method extensions\r\n- call\r\n- compose\r\n- with_args\r\n- flip\r\n- curry\r\n\r\n#### alias :< to Proc#call\r\n\r\n```ruby\r\n  f = lambda{|x| x.to_s }\r\n  f < :foo # => \"foo\"\r\n```\r\n\r\n#### alias :+@ to Proc#to_proc\r\n\r\n```ruby\r\n  +:to_s           # => #<Proc:0x007ff78aadaa78>\r\n  +:to_s < :foo    # => \"foo\"\r\n```\r\n\r\n\r\n#### Proc#compose\r\n\r\nReturns new lambda which composed self and given function.\r\nA composed proc called with args, executes `self.(g(*args)).\r\n\r\n```ruby\r\n  f = lambda{|x| x.to_s * 2 }\r\n  g = lambda{|y| y.length }\r\n\r\n  h = f.compose g  # => #<Proc:0x007ff78aa2ab2>\r\n  h.(:hoge)        # => \"44\" ( == f.call(g.call(:hoge)) )\r\n```\r\n\r\nThis method is aliased as `<<`.\r\n\r\n```ruby\r\n  f << g          # => f.compose(g)\r\n  f << g < :hoge  # => \"44\" ( == f.call(g.call(:hoge)) )\r\n```\r\n\r\n#### Proc#lift\r\n\r\nLift this function to the given context-function.\r\nThe lifted fucntion can compose other function with context-fucntion.\r\n\r\nThe given context-fuction used by `compose_with_lifting`\r\nto compose other fucntion.\r\n\r\nThe context-funciton should recieve 2 arguments.\r\n\r\n- first one is a function that reciver function of `compose_with_lifting` method.\r\n- second arg is a result of g(x)\r\n  - g is a function passed to `compose_with_lifting`\r\n\r\n\r\n#### Proc#compose_with_lifting\r\n\r\nCompose self and given function on the context-function.\r\nThe context-funciton is passed by `lift` method.\r\n\r\nThis method returns composed funciton like bellow.\r\n\r\n```ruby\r\n lambda{|args|  context(self, g(*args)) }\r\n```\r\n\r\nFor example, set context-function that logging the result.\r\n\r\n```ruby\r\n  hash = {:a => \"foo\"}\r\n  f = lambda{|x| x.length}\r\n  g = lambda{|y| hash[y]}\r\n\r\n  ctx = lambda{|f,x|\r\n    puts \"g(x)    -> #{x}\"\r\n    y = f.call(x)\r\n    puts \"f(g(x)) -> #{y}\"\r\n    y\r\n  }\r\n\r\n  lifted = f.lift(ctx)\r\n  h = lifted.compose_with_lifting g\r\n\r\n  h.(:a)\r\n  #=>  g(x)    -> foo # output by ctx\r\n  #=>  f(g(x)) -> 3   # output by ctx\r\n  #=> 3\r\n```\r\n\r\nif context-function does not given,\r\ndefault behaivior is compose function with checking g(x) is mzoro\r\n\r\nif g(x) is mzero, it does not call self and return g(x),\r\notherwise returns f(g(x)).\r\n\r\nmzero means the object is nil or emtpy\r\n\r\n```ruby\r\n  hash = {:a => \"foo\"}\r\n  f = lambda{|y| y.length }\r\n  g = lambda{|y| hash[y]}\r\n  h = f.compose_with_lifting g\r\n  h.(:a) # => 3\r\n  h.(:b) # => nil (it does not called f)\r\n```\r\n\r\nThis method is aliased as `<=`.\r\n\r\n```ruby\r\n  f <= g # => f.compose_with_lifting(g)\r\n```\r\n\r\n#### Proc#with_args\r\n\r\nReturns partially applied function that has 2nd and more parameters are\r\nfixed by given *args.\r\n\r\n```ruby\r\n  f = lambda{|x, y, z| [x, y, z]}\r\n\r\n  h = f.with_args(:a, :b)   # => #<Proc:0x007ff78a9c5ca0>\r\n  h.(:c)                    # => [:c, :a, :b] ( == f.call(:c, :a, :b) )\r\n```\r\n\r\nThis method is aliased as `*`.\r\n\r\n```ruby\r\n  f = lambda{|x, y| [x, y]}\r\n\r\n  f * :foo          # => #<Proc:0x007ff78a987540> (== f.with_args(:foo) )\r\n  f * :foo < :bar   # => [:bar,  :foo] ( == f.with_args(:foo).call(:bar) )\r\n```\r\n\r\n\r\n#### Proc#flip\r\n\r\nReturns function whose parameter order swaped 1st for 2nd.\r\nA result of filped fuction is curried by Proc#curry.\r\n\r\n```ruby\r\n  f = lambda{|x, y, z| [x, y, z]}\r\n\r\n  h = f.flip                    # => #<Proc:0x007ff78a942fa>\r\n  h.call(:a).call(:b).call(:c)  # => [:b, :a, :c] (== f.curry.call(:b).call(:a).call(:b))\r\n  h < :a < :b < :c              # => [:b, :a, :c] (== f.curry.call(:b).call(:a).call(:b))\r\n```\r\n\r\nIf arguments is var-args, pass explicitly arity to curring.\r\n\r\n```ruby\r\n  p = Proc.new{|*args| args.inspect }\r\n\r\n  p.arity                           # => -1\r\n  p.flip(3).call(:a).(:b).(:c)      # => \"[:b, :a, :c]\"\r\n  p.flip(4).call(:a).(:b).(:c).(:d) # => \"[:b, :a, :c, :d]\"\r\n```\r\n\r\nIf arity is 0 or 1, flip returns itself.\r\n\r\nThis method is aliased as `~@`.\r\n\r\n```ruby\r\n  ~f # =>             #<Proc:0x007ff78a8e22c> (== f.filp)\r\n  ~f < :a < :b < :c   # => [:b, :a, :c] (== f.filp.call(:b).call(:a).call(:b))\r\n\r\n```\r\n\r\n### Symbol extensions\r\n- to_method\r\n- to_method_with_args\r\n\r\n#### Symbol#to_method\r\n\r\nSymbol#to_method generates a function that extract Method object from given argument.\r\nThis method is aliased as `-@`.\r\n\r\n```ruby\r\n  (-:index).call(\"foobarbaz\")             # => #<Method: String#index>\r\n  (-:index).call(\"foobarbaz\").call(\"bar\") # => 3 (== \"foobarbaz\".index(\"bar\") )\r\n\r\n  -:index < \"foobarbaz\"         # => #<Method: String#index>\r\n  -:index < \"foobarbaz\" < \"bar\" # => 3 (== \"foobarbaz\".index(\"bar\") )\r\n```\r\n\r\n#### Symbol#to_method_with_args\r\n\r\nSymbol#to_method_with_args generates a function that extract Method object from given object,\r\nand returns function is partially applied parameters by passed arguments.\r\nIt is same as Symbol#to_method with Proc#with_args.\r\n\r\nThis method is aliased as `&`.\r\n\r\n```ruby\r\n  :index.to_method_with_args(\"bar\")                   #  => #<Proc:0x007ffef4886ff8\r\n  :index.to_method_with_args(\"bar\").call(\"foobarbaz\") #  => 3 (== \"foobarbaz\".index(\"bar\") )\r\n\r\n  :index & \"bar\"               #  => #<Proc:0x007ffef4886ff8\r\n  :index & \"bar\" < \"foobarbaz\" #  => 3 (== \"foobarbaz\".index(\"bar\") )\r\n```\r\n\r\n### Class extensions\r\n- alias instance_method, :/\r\n\r\n```ruby\r\n  String / :index # => #<UnboundMethod: String#index>\r\n```\r\n\r\n### UnboundMethod extensions\r\n- alias bind, :<\r\n\r\n```ruby\r\n  String / :index                    # => #<UnboundMethod: String#index>\r\n  String / :index < \"foobarbaz\"      # => #<Method: String#index>\r\n  String / :index < \"foobarbaz\" < 3  # => 3 (== \"foobarbaz\".index(\"bar\") )\r\n```\r\n\r\n### Combinators\r\n<!-- - && || -->\r\n- ski combinator\r\n\r\n### Object extensions\r\n- obj.revapply(|>)\r\n- obj._\r\n- obj.disjunction(f)\r\n\r\n#### Object#revapply\r\n\r\n`Object#revapply` is applies self to given proc/block.\r\n\r\n```ruby\r\n  f = lambda{|x| x * 2 }\r\n\r\n  \"foo\".revapply(f) #  => \"fooffoo\" (== f.call(\"foo\") )\r\n```\r\n\r\n#### Object#_\r\n\r\nObject#_ is shortcut to quickly extract Method object.\r\n\r\n```ruby\r\n\"foobarbaz\"._.index         # => #<Method: String#index>\r\n\"foobarbaz\"._.index < \"bar\" # => 3 (== \"foobarbaz\".index(\"bar\") )\r\n\r\n2._(:>=)                    # => #<Method: Fixnum#>=>\r\n[1, 2, 3].select(&2._(:>=)) # => [1, 2]( = [1, 2].select{|n| 2 >= n})\r\n```\r\n\r\n#### Object#disjunction\r\n\r\n`Object#disjunction` select self or result of applied self to given function.\r\nif f(self) is nil, returns self, otherwise return f(self).\r\n\r\n```ruby\r\n  f = lambda{|x| x % 2 == 0 ? nil : x * 2}\r\n\r\n  2.disjunction(f) # => 2 (disjunction returns reciever object)\r\n  3.disjunction(f) # => 6 (disjunction returns f(3) )\r\n```\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}