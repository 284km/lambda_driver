{"name":"LambdaDriver","tagline":"虚弦斥力場生成システム","body":"# LambdaDriver\r\n\r\n虚弦斥力場生成システム\r\n\r\nLambdaDriver drives your code more functional.\r\n\r\n```ruby\r\n# [:foo, :bar, :baz].map{|s| s.to_s }.map{|s| s.upcase }\r\n# [:foo, :bar, :baz].map(&:to_s).map(&:upcase)\r\n\r\n[:foo, :bar, :baz].map(&:to_s >> :upcase ) # => [\"FOO\",  \"BAR\",  \"BAZ\"]\r\n```\r\n\r\n```ruby\r\n# [:foo, :hoge, :bar, :fuga].select{|s| s.to_s.length > 3} # => [:hoge, :fuga]\r\n\r\n[:foo, :hoge, :bar, :fuga].select(&:to_s >> :length >> 3._(:<)) # => [:hoge, :fuga]\r\n```\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'lambda_driver'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install lambda_driver\r\n\r\n## Usage\r\n\r\n### Proc/lambda/Symbol/Method extensions\r\n- call\r\n- compose\r\n- with_args\r\n- flip\r\n- curry\r\n\r\n#### alias :< to Proc#call\r\n\r\n```ruby\r\n  f = lamdba{|x| x.to_s }\r\n  f < :foo # => \"foo\"\r\n```\r\n\r\n#### Proc#compose\r\n\r\nReturns new lambda which composed self and given function.\r\nA composed proc called with args, executes `self.(g(*args)).\r\n\r\n```ruby\r\n  f = lamdba{|x| x.to_s }\r\n  g = lambda{|y| y.length }\r\n  h = f compose g\r\n  h.(:hoge) # => 4\r\n```\r\n\r\nThis method is aliased as `<<`.\r\n\r\n```ruby\r\n  f << g # => f.compose(g)\r\n```\r\n\r\n#### Proc#with_args\r\n\r\nReturns partially applied function that has 2nd and more parameters\r\nfixed by given *args.\r\n\r\n```ruby\r\n  f = lamdba{|x, y, z| [x, y, z]}\r\n  h = f.with_args(:a, :b)\r\n  h.(:c) # => [:c, :a, :b]\r\n```\r\n\r\nThis method is aliased as `*`.\r\n\r\n```ruby\r\n  f * :foo  # => f.with_args(:foo)\r\n```\r\n\r\n\r\n#### Proc#flip\r\n\r\nReturns function whose parameter order spawed 1st for 2nd.\r\nA result of filped fuction is curried by Proc#curry.\r\n\r\n```ruby\r\n  f = lamdba{|x, y, z| [x, y, z]}\r\n  h = f.flip\r\n  h.(:a).(:b).(:c) # => [:b, :a, :c]\r\n```\r\n\r\nIf arguments is var-args, pass explicitly arity to curring.\r\n\r\n```ruby\r\n  p = Proc.new{|*args| args.inspect }\r\n  p.flip(3).call(:a).(:b).(:c)      # => \"[:b, :a, :c]\"\r\n  p.flip(4).call(:a).(:b).(:c).(:d) # => \"[:b, :a, :c, :d]\"\r\n```\r\n\r\nIf arity is 0 or 1, flip returns itself.\r\n\r\nThis method is aliased as `~@`.\r\n\r\n```ruby\r\n  ~f # => f.filp\r\n```\r\n\r\n<!-- Symbol extensions -->\r\n<!-- - to_method -->\r\n\r\n### Class extensions\r\n- alias instance_method, :/\r\n\r\n```ruby\r\n  String / :index # => #<UnboundMethod: String#index>\r\n```\r\n\r\n### UnboundMethod extensions\r\n- alias bind, :<\r\n\r\n```ruby\r\n  String / :index                    # => #<UnboundMethod: String#index>\r\n  String / :index < \"foobarbaz\"      # => #<Method: String#index>\r\n  String / :index < \"foobarbaz\" < 3  # => 3 (== \"foobarbaz\".index(3) )\r\n```\r\n\r\n### Combinators\r\n<!-- - && || -->\r\n- ski combinator\r\n\r\n### Object extensions\r\n- ap(|>) :  obj.ap(f) => f.call(obj)\r\n- obj._.method : returns obj.method(method) or lamdba{|*args| obj.send(method, *args) }\r\n<!-- - obj.disjunction(f) : if f(self) is nil, return self else return f(self) -->\r\n\r\n#### Object#ap\r\n\r\n`Object#ap` is applies self to given proc/block.\r\n\r\n```ruby\r\n  f = lambda{|x| x * 2 }\r\n  \"foo\".ap(f) #  => \"fooffoo\"\r\n```\r\n\r\n#### Object#_\r\n\r\nObject#op is shortcut to quickly extract Method object.\r\n\r\n```ruby\r\n\"foobarbaz\"._.index         #=> #<Method: String#index>\r\n\"foobarbaz\"._.index < \"bar\" # => 3 (== \"foobarbaz\".index(3) )\r\n\r\n2._(:>=) # => #<Method: Fixnum#>=>\r\n[1, 2, 3].select(&2._(:>=)) # => [1, 2]( = [1, 2].select{|n| 2 >= n})\r\n```\r\n\r\n\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}